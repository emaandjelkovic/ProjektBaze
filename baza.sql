--1) kreiranje baze AccountManager
CREATE DATABASE "AccountManager";

--2) u pgAdmin4 ili nekom drugom management studiu otvoriti query za bazu "AccountManager" i pokrenuti skriptu pod korakom 3.


-- 3) kreiranje tablica, view-ova, triggera,procedura

CREATE TABLE IF NOT EXISTS "__EFMigrationsHistory" (
    "MigrationId" character varying(150) NOT NULL,
    "ProductVersion" character varying(32) NOT NULL,
    CONSTRAINT "PK___EFMigrationsHistory" PRIMARY KEY ("MigrationId")
);

START TRANSACTION;
CREATE TABLE permissions (
    "Id" integer GENERATED BY DEFAULT AS IDENTITY,
    "Code" character varying(50) NOT NULL,
    "Name" character varying(200) NOT NULL,
    CONSTRAINT "PK_permissions" PRIMARY KEY ("Id")
);

CREATE TABLE roles (
    "Id" integer GENERATED BY DEFAULT AS IDENTITY,
    "Name" character varying(20) NOT NULL,
    CONSTRAINT "PK_roles" PRIMARY KEY ("Id")
);

CREATE TABLE user_audit_logs (
    "Id" integer GENERATED BY DEFAULT AS IDENTITY,
    "UserId" integer NOT NULL,
    "Action" text NOT NULL,
    "ChangedAt" timestamp with time zone NOT NULL DEFAULT (now()),
    "OldData" text,
    "NewData" text,
    CONSTRAINT "PK_user_audit_logs" PRIMARY KEY ("Id")
);

CREATE TABLE role_permissions (
    "RoleId" integer NOT NULL,
    "PermissionId" integer NOT NULL,
    CONSTRAINT "PK_role_permissions" PRIMARY KEY ("RoleId", "PermissionId"),
    CONSTRAINT "FK_role_permissions_permissions_PermissionId" FOREIGN KEY ("PermissionId") REFERENCES permissions ("Id") ON DELETE CASCADE,
    CONSTRAINT "FK_role_permissions_roles_RoleId" FOREIGN KEY ("RoleId") REFERENCES roles ("Id") ON DELETE CASCADE
);

CREATE TABLE users (
    "Id" integer GENERATED BY DEFAULT AS IDENTITY,
    "Email" character varying(200) NOT NULL,
    "Password" text NOT NULL,
    "RoleId" integer NOT NULL,
    "CreatedAt" timestamp with time zone NOT NULL,
    CONSTRAINT "PK_users" PRIMARY KEY ("Id"),
    CONSTRAINT "FK_users_roles_RoleId" FOREIGN KEY ("RoleId") REFERENCES roles ("Id") ON DELETE RESTRICT
);

CREATE TABLE accounts (
    "Id" integer GENERATED BY DEFAULT AS IDENTITY,
    "UserId" integer NOT NULL,
    "FirstName" character varying(100) NOT NULL,
    "LastName" character varying(100) NOT NULL,
    "DateOfBirth" date NOT NULL,
    "Address" character varying(300) NOT NULL,
    CONSTRAINT "PK_accounts" PRIMARY KEY ("Id"),
    CONSTRAINT "FK_accounts_users_UserId" FOREIGN KEY ("UserId") REFERENCES users ("Id") ON DELETE CASCADE
);

CREATE TABLE user_sessions (
    "Id" uuid NOT NULL,
    "UserId" integer NOT NULL,
    "CreatedAt" timestamp with time zone NOT NULL DEFAULT (now()),
    "LastSeenAt" timestamp with time zone NOT NULL DEFAULT (now()),
    "IpAddress" character varying(50),
    "UserAgent" character varying(300),
    "RevokedAt" timestamp with time zone,
    CONSTRAINT "PK_user_sessions" PRIMARY KEY ("Id"),
    CONSTRAINT "FK_user_sessions_users_UserId" FOREIGN KEY ("UserId") REFERENCES users ("Id") ON DELETE CASCADE
);

INSERT INTO permissions ("Id", "Code", "Name")
VALUES (1, 'USERS_VIEW', 'Pregled korisnika');
INSERT INTO permissions ("Id", "Code", "Name")
VALUES (2, 'USERS_ROLE_CHANGE', 'Promjena role korisnika');
INSERT INTO permissions ("Id", "Code", "Name")
VALUES (3, 'ACCOUNTS_VIEW', 'Pregled računa');
INSERT INTO permissions ("Id", "Code", "Name")
VALUES (4, 'AUDIT_VIEW', 'Pregled audita');

INSERT INTO roles ("Id", "Name")
VALUES (1, 'User');
INSERT INTO roles ("Id", "Name")
VALUES (2, 'Admin');

INSERT INTO role_permissions ("PermissionId", "RoleId")
VALUES (1, 2);
INSERT INTO role_permissions ("PermissionId", "RoleId")
VALUES (2, 2);
INSERT INTO role_permissions ("PermissionId", "RoleId")
VALUES (3, 2);
INSERT INTO role_permissions ("PermissionId", "RoleId")
VALUES (4, 2);

CREATE UNIQUE INDEX "IX_accounts_UserId" ON accounts ("UserId");

CREATE UNIQUE INDEX "IX_permissions_Code" ON permissions ("Code");

CREATE INDEX "IX_role_permissions_PermissionId" ON role_permissions ("PermissionId");

CREATE UNIQUE INDEX "IX_roles_Name" ON roles ("Name");

CREATE INDEX "IX_user_audit_logs_UserId" ON user_audit_logs ("UserId");

CREATE INDEX "IX_user_sessions_UserId" ON user_sessions ("UserId");

CREATE UNIQUE INDEX "IX_users_Email" ON users ("Email");

CREATE INDEX "IX_users_RoleId" ON users ("RoleId");

CREATE TABLE account_audit_logs (
    "Id" bigint GENERATED BY DEFAULT AS IDENTITY,
    "AccountId" integer,
    "UserId" integer,
    "Action" text NOT NULL,
    "ChangedAt" timestamp with time zone NOT NULL DEFAULT (now()),
    "OldData" text,
    "NewData" text,
    CONSTRAINT "PK_account_audit_logs" PRIMARY KEY ("Id")
);

CREATE INDEX "IX_account_audit_logs_AccountId" ON account_audit_logs ("AccountId");

CREATE INDEX "IX_account_audit_logs_UserId" ON account_audit_logs ("UserId");


CREATE OR REPLACE FUNCTION user_has_account(p_user_id integer)
RETURNS boolean
LANGUAGE sql
AS $$
    SELECT EXISTS (
        SELECT 1 FROM accounts WHERE "UserId" = p_user_id
    );
$$;



CREATE OR REPLACE FUNCTION fn_account_audit()
RETURNS trigger
LANGUAGE plpgsql
AS $$
BEGIN
    IF (TG_OP = 'INSERT') THEN
        INSERT INTO account_audit_logs("AccountId", "UserId", "Action", "ChangedAt", "OldData", "NewData")
        VALUES (NEW."Id", NEW."UserId", 'INSERT', now(), NULL, row_to_json(NEW)::text);
        RETURN NEW;

    ELSIF (TG_OP = 'UPDATE') THEN
        INSERT INTO account_audit_logs("AccountId", "UserId", "Action", "ChangedAt", "OldData", "NewData")
        VALUES (NEW."Id", NEW."UserId", 'UPDATE', now(), row_to_json(OLD)::text, row_to_json(NEW)::text);
        RETURN NEW;

    ELSIF (TG_OP = 'DELETE') THEN
        INSERT INTO account_audit_logs("AccountId", "UserId", "Action", "ChangedAt", "OldData", "NewData")
        VALUES (OLD."Id", OLD."UserId", 'DELETE', now(), row_to_json(OLD)::text, NULL);
        RETURN OLD;
    END IF;

    RETURN NULL;
END;
$$;



DROP TRIGGER IF EXISTS trg_account_audit ON accounts;

CREATE TRIGGER trg_account_audit
AFTER INSERT OR UPDATE OR DELETE ON accounts
FOR EACH ROW
EXECUTE FUNCTION fn_account_audit();



CREATE OR REPLACE VIEW vw_admin_accounts AS
SELECT
    a."Id"           AS "AccountId",
    a."UserId"       AS "UserId",
    u."Email"        AS "UserEmail",
    r."Name"         AS "UserRole",
    a."FirstName"    AS "FirstName",
    a."LastName"     AS "LastName",
    a."DateOfBirth"  AS "DateOfBirth",
    a."Address"      AS "Address"
FROM accounts a
JOIN users u ON u."Id" = a."UserId"
JOIN roles r ON r."Id" = u."RoleId";



CREATE OR REPLACE PROCEDURE public.sp_admin_set_role(
    IN p_user_id integer,
    IN p_role_id integer
)
LANGUAGE plpgsql
AS $$
BEGIN
    -- provjera postoji li user
    IF NOT EXISTS (SELECT 1 FROM users WHERE "Id" = p_user_id) THEN
        RAISE EXCEPTION 'User not found id=%', p_user_id
            USING ERRCODE = 'P0002';
    END IF;

    -- provjera postoji li rola
    IF NOT EXISTS (SELECT 1 FROM roles WHERE "Id" = p_role_id) THEN
        RAISE EXCEPTION 'Role not found id=%', p_role_id
            USING ERRCODE = 'P0003';
    END IF;

    -- promjena role
    UPDATE users
    SET "RoleId" = p_role_id
    WHERE "Id" = p_user_id;
END;
$$;



CREATE OR REPLACE FUNCTION fn_user_audit()
RETURNS trigger
LANGUAGE plpgsql
AS $$
BEGIN
    IF (TG_OP = 'INSERT') THEN
        INSERT INTO user_audit_logs("UserId", "Action", "ChangedAt", "OldData", "NewData")
        VALUES (NEW."Id", 'INSERT', now(), NULL, row_to_json(NEW)::text);
        RETURN NEW;

    ELSIF (TG_OP = 'UPDATE') THEN
        INSERT INTO user_audit_logs("UserId", "Action", "ChangedAt", "OldData", "NewData")
        VALUES (NEW."Id", 'UPDATE', now(), row_to_json(OLD)::text, row_to_json(NEW)::text);
        RETURN NEW;

    ELSIF (TG_OP = 'DELETE') THEN
        INSERT INTO user_audit_logs("UserId", "Action", "ChangedAt", "OldData", "NewData")
        VALUES (OLD."Id", 'DELETE', now(), row_to_json(OLD)::text, NULL);
        RETURN OLD;
    END IF;

    RETURN NULL;
END;
$$;

DROP TRIGGER IF EXISTS trg_user_audit ON users;

CREATE TRIGGER trg_user_audit
AFTER INSERT OR UPDATE OR DELETE ON users
FOR EACH ROW
EXECUTE FUNCTION fn_user_audit();



CREATE OR REPLACE FUNCTION user_has_permission(p_user_id integer, p_perm_code text)
RETURNS boolean
LANGUAGE sql
AS $$
    SELECT EXISTS (
        SELECT 1
        FROM users u
        JOIN role_permissions rp ON rp."RoleId" = u."RoleId"
        JOIN permissions p ON p."Id" = rp."PermissionId"
        WHERE u."Id" = p_user_id
          AND p."Code" = p_perm_code
    );
$$;



CREATE OR REPLACE PROCEDURE sp_revoke_user_sessions(IN p_user_id integer)
LANGUAGE plpgsql
AS $$
BEGIN
    UPDATE user_sessions
    SET "RevokedAt" = now()
    WHERE "UserId" = p_user_id
      AND "RevokedAt" IS NULL;
END;
$$;


SELECT setval(
    pg_get_serial_sequence('permissions', 'Id'),
    GREATEST(
        (SELECT MAX("Id") FROM permissions) + 1,
        nextval(pg_get_serial_sequence('permissions', 'Id'))),
    false);
SELECT setval(
    pg_get_serial_sequence('roles', 'Id'),
    GREATEST(
        (SELECT MAX("Id") FROM roles) + 1,
        nextval(pg_get_serial_sequence('roles', 'Id'))),
    false);

INSERT INTO "__EFMigrationsHistory" ("MigrationId", "ProductVersion")
VALUES ('20260117092601_Initial', '9.0.10');

COMMIT;

